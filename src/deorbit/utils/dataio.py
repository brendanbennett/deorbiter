import json
import os
import pickle
from abc import ABC, abstractmethod
from datetime import datetime
from pathlib import Path

from deorbit.data_models.sim import SimData


class DataIO(ABC):
    name: None | str = None
    
    def __init__(self):
        if self.name is None:
            raise ValueError("DataIO subclasses must define a name attribute")

    @abstractmethod
    def save(self, data: SimData, path) -> None: ...

    @abstractmethod
    def load(self, path) -> SimData: ...


class JSONIO(DataIO):
    name = "json"

    def save(self, data: SimData, path) -> None:
        with open(path, "w") as f:
            json.dump(data.model_dump_json(), f)

    def load(self, path) -> SimData:
        with open(path) as f:
            model = SimData.model_validate_json(json.load(f))
            return model


class PickleIO(DataIO):
    name = "pkl"
    
    def save(self, data: SimData, path) -> None:
        with open(path, "wb") as f:
            pickle.dump(data, f)

    def load(self, path) -> SimData:
        with open(path, "rb") as f:
            model = pickle.load(f)
            return model


formats = {io.name: io for io in DataIO.__subclasses__()}


def save_sim_data(data: SimData, dir_path_string: str, format: str) -> Path:
    """Saves the simulation data `data` as a json file.
    The json filename is auto-generated by `dataio._get_filename()`.

    Args:
        data (SimData): Data to be saved
        dir_path_string (str): Directory where the `data` json with be saved.
        format (str): Data file format to use. Default: `json`

    Raises:
        NotADirectoryError: Raised if `dir_path_string` exists and is not a valid directory.

    Returns:
        Path: Path to the saved data file.
    """
    dir_path = Path(dir_path_string)
    _check_for_dir(dir_path)

    path = _get_filename("sim_data", dir_path=dir_path, file_type=format)

    path = _check_for_file(path)

    io = formats[format]()

    io.save(data, path)

    return path


def _get_filename(
    stem: str, dir_path: None | str = None, file_type: None | str = None
) -> str:
    """Generates filenames in the format [dir_path]/[stem]_yyyymmdd_hhmmss.[file_type]

    Args:
        stem (str): Stem for the filename.
        dir_path (optional, str): Directory path prefix
        file_type (optional, str): file type suffix

    Returns:
        Path: filename, with optional suffix and directory path
    """
    # time() give floating point unix time.
    t = datetime.utcnow().timetuple()
    timestamp = (
        f"{t[0]:0>4d}{t[1]:0>2d}{t[2]:0>2d}_{t[3]:0>2d}{t[4]:0>2d}{t[5]:0>2d}"
    )

    if dir_path is None:
        dir_path = ""

    if file_type is None:
        file_type = ""
    else:
        file_type = "." + file_type

    filename = stem + "_" + timestamp + file_type

    return Path(dir_path, filename)


def _check_for_dir(path: Path, create: bool = True) -> None:
    """Checks a path for an existing directory. If one doesn't exist,
    optionally create a directory.

    Args:
        path (Path): Path to check
        create (bool, optional): Create the directory if it doesn't exist

    Raises:
        NotADirectoryError: Raise if the path already exists and is not a directory
    """

    if not path.exists():
        os.makedirs(path)
    elif not path.is_dir():
        raise NotADirectoryError(f"{path} is not a directory")


def _check_for_file(path: Path) -> Path:
    """Given a path to a file, check if the file already exists.
    If so, append `_[number]` to the filename where `number` is the
    lowest number such that the file name is unique.

    Args:
        path (Path): File path to be checked

    Returns:
        Path: Potentially modified, unique file path
    """
    if path.exists():
        stem = path.stem
        i = 1
        while path.exists():
            path = path.with_stem(stem + "_" + str(i))
            i += 1
    return path


def load_sim_data(path: str) -> SimData:
    path: Path = Path(path)
    # format is defined by extension
    io = formats[path.suffix[1:]]()
    
    sim_data = io.load(path)
    return sim_data
