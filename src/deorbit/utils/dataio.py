import json
import os
import pickle
from abc import ABC, abstractmethod
from datetime import datetime
from pathlib import Path

from pydantic import BaseModel

from deorbit.data_models.sim import SimConfig, SimData

DATA_STEM = "data"
CONFIG_STEM = "config"
CONFIG_FMT = "pkl"


class DataIO(ABC):
    name: None | str = None

    def __init__(self):
        if self.name is None:
            raise ValueError("DataIO subclasses must define a name attribute")

    @abstractmethod
    def save(self, data: BaseModel, path) -> None: ...

    @abstractmethod
    def load(self, path, data_model: type[BaseModel]) -> BaseModel: ...


class JSONIO(DataIO):
    name = "json"

    def save(self, data: BaseModel, path) -> None:
        with open(path, "w") as f:
            json.dump(data.model_dump_json(), f)

    def load(self, path, data_model: type[BaseModel]) -> BaseModel:
        with open(path) as f:
            model = data_model.model_validate_json(json.load(f))
            return model


class PickleIO(DataIO):
    name = "pkl"

    def save(self, data: BaseModel, path) -> None:
        with open(path, "wb") as f:
            pickle.dump(data, f)

    def load(self, path) -> BaseModel:
        with open(path, "rb") as f:
            model = pickle.load(f)
            return model


formats = {io.name: io for io in DataIO.__subclasses__()}


def _get_filename(
    stem: str,
    dir_path: None | str = None,
    file_type: None | str = None,
    run_time: datetime | None = None,
) -> str:
    """Generates filenames in the format [dir_path]/[stem]_yyyymmdd_hhmmss.[file_type]

    Args:
        stem (str): Stem for the filename.
        dir_path (optional, str): Directory path prefix
        file_type (optional, str): file type suffix

    Returns:
        Path: filename, with optional suffix and directory path
    """
    # time() give floating point unix time.
    if run_time is None:
        timestamp = ""
    else:
        timestamp = "_" + run_time.strftime("%Y%m%d_%H%M%S")

    if dir_path is None:
        dir_path = ""

    if file_type is None:
        file_type = ""
    else:
        file_type = "." + file_type

    filename = stem + timestamp + file_type

    return Path(dir_path, filename)


def _check_for_dir(path: Path) -> None:
    """Checks a path for an existing directory. If one doesn't exist,
    create a directory.

    Args:
        path (Path): Path to check
        create (bool, optional): Create the directory if it doesn't exist

    Raises:
        NotADirectoryError: Raise if the path already exists and is not a directory
    """

    if not path.exists():
        os.makedirs(path)
    elif not path.is_dir():
        raise NotADirectoryError(f"{path} is not a directory")


def _check_for_file(path: Path) -> Path:
    """Given a path to a file, check if the file already exists.
    If so, append `_[number]` to the filename where `number` is the
    lowest number such that the file name is unique.

    Args:
        path (Path): File path to be checked

    Returns:
        Path: Potentially modified, unique file path
    """
    if path.exists():
        stem = path.stem
        i = 1
        while path.exists():
            path = path.with_stem(stem + "_" + str(i))
            i += 1
    return path


def save_sim_data(
    data: SimData,
    config: SimConfig,
    dir_path_string: str,
    run_time: datetime,
    format: str = "pkl",
) -> Path:
    """Saves the simulation data `data` and config `config` in the provided format.
    The config and data are saved in separate files in a new directory.
    The new directory name is auto-generated by `dataio._get_filename()`.

    Args:
        data (SimData): Data to be saved
        dir_path_string (str): Directory where the `data` json with be saved.
        run_time (datetime): Time of the simulation run (used for filename generation)
        format (str): Data file format to use. Default: `pkl`

    Raises:
        NotADirectoryError: Raised if `dir_path_string` exists and is not a valid directory.

    Returns:
        Path: Path to the saved data file.
    """
    # Config format should be pickle as it maintains information about the model/method used

    dir_path = Path(dir_path_string) / _get_filename("sim", run_time=run_time)
    _check_for_dir(dir_path)

    data_path = _get_filename(DATA_STEM, dir_path=dir_path, file_type=format)
    data_path = _check_for_file(data_path)

    config_path = _get_filename(CONFIG_STEM, dir_path=dir_path, file_type=CONFIG_FMT)
    config_path = _check_for_file(config_path)

    io = formats[format]()
    io.save(data, data_path)
    io = formats[CONFIG_FMT]()
    io.save(config, config_path)

    return dir_path


def load_sim_data(dir_path: str) -> SimData:
    """Load the simulation data from the provided directory path.
    The simulation data file is expected to be in the format `data.[format]`.

    Args:
        dir_path (str): Directory path containing the simulation data. e.g. `./data/sim_20210101_120000/`

    Raises:
        NotADirectoryError: `dir_path` is not a directory
        FileNotFoundError: No data file found in `dir_path`

    Returns:
        SimData: Loaded simulation data
    """
    dir_path: Path = Path(dir_path)

    if not dir_path.is_dir():
        raise NotADirectoryError(f"{dir_path} is not a directory")

    for p in dir_path.iterdir():
        if p.is_file() and p.stem.startswith(DATA_STEM):
            path = p
            break
    else:
        raise FileNotFoundError(f"No data file found in {dir_path}")

    # format is defined by extension
    format = path.suffix[1:]
    io = formats[format]()
    # json loader needs the target datamodel
    if format == "json":
        sim_data = io.load(path, data_model=SimData)
    else:
        sim_data = io.load(path)
    return sim_data


def load_sim_config(dir_path: str) -> SimConfig:
    """Load the simulation config from the provided directory path.
    The config file is expected to be in the format `config.pkl`.

    Args:
        dir_path (str): Directory path containing the simulation config. e.g. `./data/sim_20210101_120000/`

    Raises:
        NotADirectoryError: `dir_path` is not a directory
        FileNotFoundError: No config file found in `dir_path`

    Returns:
        SimConfig: Loaded simulation config
    """
    dir_path: Path = Path(dir_path)

    if not dir_path.is_dir():
        raise NotADirectoryError(f"{dir_path} is not a directory")

    path: Path = Path(dir_path) / (CONFIG_STEM + "." + CONFIG_FMT)

    if not path.exists():
        raise FileNotFoundError(f"The file {path} does not exist")

    # format is defined by extension
    io = formats[path.suffix[1:]]()

    sim_config = io.load(path)
    return sim_config
