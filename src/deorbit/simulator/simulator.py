from abc import ABC, abstractmethod
from datetime import datetime
from pathlib import Path
from time import thread_time_ns
from typing import Callable

import numpy as np
import numpy.typing as npt
from tqdm import tqdm

from deorbit.data_models.atmos import AtmosKwargs, get_model_for_atmos
from deorbit.data_models.methods import MethodKwargs, get_model_for_sim
from deorbit.data_models.noise import (
    GaussianNoiseKwargs,
    ImpulseNoiseKwargs,
    NoiseKwargs,
)
from deorbit.data_models.sim import SimConfig, SimData
from deorbit.simulator.atmos import (
    AtmosphereModel,
    get_available_atmos_models,
    raise_for_invalid_atmos_model,
)
from deorbit.utils.constants import (
    EARTH_RADIUS,
    GM_EARTH,
    MEAN_DRAG_COEFF,
    MEAN_XSECTIONAL_AREA,
    SATELLITE_MASS,
)
from deorbit.utils.dataio import save_sim_data_and_config


class Simulator(ABC):
    """Base class for simulators."""

    _methods: dict = {}
    _available_noise_types = ["gaussian", "impulse"]

    def __init_subclass__(cls, method_name: str = None, **kwargs):
        """
        Special method called when a subclass is defined. Registers the subclass with a method name.

        :param method_name: The name of the simulation method.
        :type method_name: str
        :raises SyntaxError: If 'method_name' is not provided when defining a subclass.
        """
        # This special method is called when a _subclass_ is defined in the code.
        # This allows the `method_name` to be passed as an argument to the subclass instantiator
        if method_name is None:
            raise SyntaxError(
                "'method_name' must be supplied as an argument when defining a subclass of Simulator"
            )
        super().__init_subclass__(**kwargs)
        cls._methods[method_name] = cls

    def __new__(cls, config: SimConfig):
        """
        Create a new instance of the simulator using the specified configuration.

        :param config: The configuration object for the simulator.
        :type config: SimConfig
        :return: An instance of the simulator matching the simulation method defined in config.
        :rtype: object
        :raises ValueError: If the specified simulation method is invalid.
        """
        method_name = config.simulation_method_kwargs.method_name
        raise_for_invalid_sim_method(method_name)
        method_cls = cls._methods[method_name]
        return super().__new__(method_cls)

    def __init__(self, config: SimConfig):
        """Simulator constructor.

        :param config: The configuration object containing simulation parameters.
        :type config: SimConfig
        """
        # Here, as generated by `__new__`, `self` is actually an instance of the
        # simulator subclass matching the simulation method in `config.simulation_method_kwargs`

        self.states: list[np.ndarray] = list()
        self.times: list[float] = list()
        self._atmosphere_model: AtmosphereModel = None
        self.sim_method_kwargs: MethodKwargs = config.simulation_method_kwargs
        self.time_of_last_run = datetime.now()
        self._noise_types = None

        self._set_atmosphere_model(config.atmosphere_model_kwargs)
        self.set_initial_conditions(config.initial_state, config.initial_time)

    def export_config(self) -> SimConfig:
        """Returns a configuration object for the simulation.

        :return: Config object which can be used to recreate this simulation
        :rtype: SimConfig
        """
        assert len(self.states) > 0 and len(self.times) > 0
        config = SimConfig(
            initial_state=list(self.states[0]),
            initial_time=self.times[0],
            simulation_method_kwargs=self.sim_method_kwargs,
            atmosphere_model_kwargs=self._atmosphere_model.kwargs,
        )
        return config

    def _reset_state_and_time(self) -> None:
        """
        Resets the internal state and time lists.
        """
        self.states = list()
        self.times = list()

    def set_initial_conditions(self, state: np.ndarray, time: float) -> None:
        """Resets the simulation and initialises values with the given state vector and time

        :param state: The initial state vector
        :type state: np.ndarray
        :param time: The initial time
        :type time: float
        """
        # Makes sure state is a numpy array
        state = np.array(state, dtype=float)
        assert state.shape == (
            2 * self.dim,
        ), f"Incorrect shape for initial state {state}. Expected {(2*self.dim,)}, got {state.shape}"
        self._reset_state_and_time()
        self.states.append(state)
        self.times.append(time)

    def _set_atmosphere_model(self, model_kwargs: AtmosKwargs) -> None:
        """Sets the atmosphere model for the simulation.

        :param model_kwargs: The configuration for the atmosphere model.
        :type model_kwargs: AtmosKwargs
        """
        model_name = model_kwargs.atmos_name
        raise_for_invalid_atmos_model(model_name)
        self._atmosphere_model: AtmosphereModel = AtmosphereModel(model_kwargs)

    def _pos_from_state(self, state: np.ndarray) -> np.ndarray:
        """
        Extracts the position vector from the state vector.

        :param state: The state vector.
        :type state: np.ndarray
        :return: The position vector.
        :rtype: np.ndarray
        """
        return state[: self.dim]

    def _vel_from_state(self, state: np.ndarray) -> np.ndarray:
        """
        Extracts the velocity vector from the state vector.

        :param state: The state vector.
        :type state: np.ndarray
        :return: The velocity vector.
        :rtype: np.ndarray
        """
        return state[self.dim :]

    def atmosphere(self, state: np.ndarray, time: float) -> float:
        """Calculates the atmosphere density at a given state and time.

        :param state: The state vector
        :type state: np.ndarray
        :param time: The simulation time
        :type time: float
        :return: The atmosphere density
        :rtype: float
        """
        return self._atmosphere_model.density(state, time)

    def atmosphere_velocity(self, state: np.ndarray, time: float) -> np.ndarray:
        """Calculates the atmosphere velocity at a given state and time. Due to the Earth's rotation.

        :param state: The state vector. The velocity component is not used.
        :param time: The simulation time. Used only if the atmosphere model requires it.
        :return: The atmosphere velocity vector.
        """
        return self._atmosphere_model.velocity(state, time)

    def _gravity_accel(self, state: np.ndarray) -> np.ndarray:
        """Calculate acceleration by gravity.

        :param state: The state vector.
        :return: The acceleration vector.
        """
        position = state[: self.dim]
        radius = np.linalg.norm(position)
        return -position * GM_EARTH / (radius**3)

    def _drag_accel(self, state: np.ndarray, time: float) -> np.ndarray:
        """Calculates acceleration on the satellite due to drag in a particular state.
        Uses the chosen atmosphere model to calculate air density.

        :param state: The state vector.
        :param time: The simulation time.
        :return: The drag acceleration vector.
        """
        relative_velocity = self._vel_from_state(state) - self.atmosphere_velocity(
            state, time
        )
        accel = (
            -(1 / (2 * SATELLITE_MASS))
            * self.atmosphere(state, time)
            * MEAN_XSECTIONAL_AREA
            * MEAN_DRAG_COEFF
            * relative_velocity
            * np.linalg.norm(relative_velocity)
        )
        return accel

    def _calculate_accel(self, state: np.ndarray, time: float) -> np.ndarray:
        """Calculates the acceleration on the satellite at a given state and time, due to gravity, drag and noise.

        :param state: The state vector.
        :param time: The simulation time.
        :return: The resultant acceleration vector.
        """
        drag_accel = self._drag_accel(state=state, time=time)
        grav_accel = self._gravity_accel(state=state)
        # print(f"state {state} at time {time} has drag accel {np.linalg.norm(drag_accel)} \
        # and gravity accel {np.linalg.norm(grav_accel)}")
        if self.noise_types is None:
            return drag_accel + grav_accel

        noise_accel = 0
        if "gaussian" in self.noise_types:
            # gaussian noise accounting for random changes throughout the deorbit process
            noise_kwargs: GaussianNoiseKwargs = self.noise_types["gaussian"]
            noise_accel += np.linalg.norm(drag_accel + grav_accel) * np.random.normal(
                0, noise_kwargs.noise_strength, size=self.dim
            )

        if "impulse" in self.noise_types:
            # impulsive noise akin to one off large scale collisions within the atmosphere
            # could make chance of collison/collision frequency a parameter to be inputted by the user??
            noise_kwargs: ImpulseNoiseKwargs = self.noise_types["impulse"]
            collision_chance = np.random.random()
            if collision_chance < noise_kwargs.impulse_probability:
                # Impulse in a random direction
                direction = np.random.normal(size = self.dim)
                direction = direction/np.linalg.norm(direction)
                noise_accel += direction * noise_kwargs.impulse_strength
        return drag_accel + grav_accel + noise_accel

    def _step_time(self) -> None:
        """Steps the internal simulation time by the time step.

        :return: None
        """
        self.times.append(self.times[-1] + self.time_step)

    def _objective_function(self, state: np.ndarray, time: float) -> np.ndarray:
        """The function that gives the derivative our state vector x' = f(x,t) and defines our ODE.
        Returns a flat array (position', velocity')

        :param state: The state vector.
        :param time: The simulation time.
        :return: The derivative of the state vector.
        """
        accel = self._calculate_accel(state, time)
        return np.concatenate((state[self.dim :], accel))

    def is_terminal(self, state: np.ndarray) -> bool:
        """Checks if the satellite has impacted the Earth.

        :param state: The state vector.
        """
        return np.linalg.norm(self._pos_from_state(state)) <= EARTH_RADIUS

    @abstractmethod
    def _run_method(self, steps: int | None) -> None: ...

    def run(self, steps: int = None) -> None:
        """Runs the simulation for a specified number of steps. If steps is not provided, runs until the satellite impacts the Earth.

        :param steps: The number of steps to run the simulation for. Optional.
        """
        self.time_of_last_run = datetime.now()
        start_time = thread_time_ns()

        # Run with selected simulation method
        self._run_method(steps)

        elapsed_time = (thread_time_ns() - start_time) * 1e-9

        if self.is_terminal(self.states[-1]):
            print(
                f"Impacted at {self.states[-1][:self.dim]} at velocity {self.states[-1][self.dim:]} at simulated time {self.times[-1]}s."
            )

        print(f"Simulation finished in {elapsed_time:.5f} seconds")

    @property
    def time_step(self) -> float:
        """The time step for the simulation.

        :return: The time step for the simulation.
        """
        return self.sim_method_kwargs.time_step

    @time_step.setter
    def time_step(self, value):
        self.sim_method_kwargs.time_step = value

    @property
    def dim(self) -> int:
        """The dimension of the simulation. 2 for 2D, 3 for 3D.

        :return: The dimension of the simulation.
        """
        return self.sim_method_kwargs.dimension

    @property
    def noise_types(self) -> dict[str, NoiseKwargs]:
        """Returns a dictionary of noise types and their parameters. Empty dict if no noise is present.

        :return: The noise types and their parameters.
        """
        return self.sim_method_kwargs.noise_types

    def gather_data(self) -> SimData:
        """Generates a portable data object containing all the simulation data reqiured to save.

        :return: The simulation data object.
        """
        states = np.array(self.states)
        assert self.dim * 2 == states.shape[1]

        if self.dim == 2:
            data = SimData(
                x1=states[:, 0],
                x2=states[:, 1],
                v1=states[:, 2],
                v2=states[:, 3],
                times=self.times,
            )
        elif self.dim == 3:
            data = SimData(
                x1=states[:, 0],
                x2=states[:, 1],
                x3=states[:, 2],
                v1=states[:, 3],
                v2=states[:, 4],
                v3=states[:, 5],
                times=self.times,
            )
        else:
            raise Exception("Sim dimension is not 2 or 3!")
        return data

    def save_data(
        self, save_dir_path: str | Path, overwrite: bool = True, format: str = "pkl"
    ) -> Path:
        """Saves simulation data to `save_dir_path` directory in the `format` format.

        :param save_dir_path: The directory to save the data to. Creates the directory if it does not exist.
        :param overwrite: Whether to overwrite existing files. Defaults to True.
        :param format: The format to save the data in. One of "json", "pkl". Defaults to "pkl".
        :return: The path to the save directory. Used to load the data later.
        """
        save_path = save_sim_data_and_config(
            self.gather_data(),
            self.export_config(),
            save_path=save_dir_path,
            overwrite=overwrite,
            format=format,
        )
        return save_path


class EulerSimulator(Simulator, method_name="euler"):
    """
    Simulator class implementing the Euler integration method.
    """

    def _next_state(self, state, time) -> np.ndarray:
        """
        Calculate the next state using the Euler method.

        :param state: The current state vector.
        :type state: np.ndarray
        :param time: The current simulation time.
        :type time: float
        :return: The next state vector.
        :rtype: np.ndarray
        """
        # Calculate the next state using the Euler method
        dt = self.time_step
        next_state = state + self._objective_function(state, time) * dt

        return next_state

    def _step_state(self) -> None:
        """
        Step the state of the simulation by one time step using the Euler method.
        """
        self._step_time()
        # Saving the new state
        self.states.append(self._next_state(self.states[-1], self.times[-1]))

    def _run_method(self, steps: int | None) -> None:
        """
        Simple forward euler integration technique. Run the simulation using the Euler integration method.

        :param steps: The number of steps to run the simulation for. If None, runs until the satellite impacts the Earth.
        :type steps: int or None
        """
        if len(self.noise_types) == 0:
            print(
                f"Running simulation with Euler integrator without noise"
            )
        else:
            print(
                f"Running simulation with Euler integrator with {self.noise_types} noise"
            )
        # Boilerplate code for stepping the simulation
        if steps is None:
            iters = 0
            while not self.is_terminal(self.states[-1]):
                self._step_state()
                iters += 1
        else:
            for i in tqdm(range(steps)):
                if self.is_terminal(self.states[-1]):
                    iters = i
                    break
                self._step_state()
            else:
                iters = steps

        print(f"Ran {iters} iterations at time step of {self.time_step} seconds")


class AdamsBashforthSimulator(Simulator, method_name="adams_bashforth"):
    """
    Simulator class implementing the two-step Adams-Bashforth integration method.
    """
    
    def _step_state_euler(self) -> None:
        """
        Step the state of the simulation by one time step using the Euler method for initialization.
        """
        self._step_time()
        next_state = np.array(self.states[-1], dtype=float)
        next_state += (
            self._objective_function(self.states[-1], self.times[-1]) * self.time_step
        )
        self.states.append(next_state)

    def _step_state(self, buffer: list) -> None:
        """
        Step the state of the simulation by one time step using the Adams-Bashforth method.

        :param buffer: A list containing the previous function evaluations.
        :type buffer: list
        """
        func_n_minus_2, func_n_minus_1 = buffer
        # Update with two step Adams-Bashforth
        next_state = (
            self.states[-1]
            + (3 / 2) * self.time_step * func_n_minus_1
            - (1 / 2) * self.time_step * func_n_minus_2
        )
        # Update buffer with next function evaluation f(xn, tn)
        self._step_time()
        buffer.append(self._objective_function(next_state, self.times[-1]))
        del buffer[0]
        self.states.append(next_state)

    def _run_method(self, steps: int | None) -> None:
        """
        Two-step Adams-Bashforth integration technique.

        A linear multistep method that only samples the function at the same time steps as are output.
        This contrasts with the Runge-Kutta methods which take intermediatesamples between time steps.
        This allows buffering of previous calls to the right-hand-side function of the ODE which is
        fairly expensive.
        
        :param steps: The number of steps to run the simulation for. If None, runs until the satellite impacts the Earth.
        :type steps: int or None
        """
        if len(self.noise_types) == 0:
            print(
                f"Running simulation with Two-step Adams-Bashforth integrator without noise"
            )
        else:
            print(
                f"Running simulation with Two-step Adams-Bashforth integrator with {self.noise_types} noise"
            )
        function_buffer = list()
        iters = 0
        # Initialise function buffer with f(x0, t0) and f(x1, t1)
        function_buffer.append(
            self._objective_function(self.states[-1], self.times[-1])
        )
        # We calculate f(x1, t1) using the forward euler method.
        self._step_state_euler()
        function_buffer.append(
            self._objective_function(self.states[-1], self.times[-1])
        )
        # Boilerplate code for stepping the simulation
        if steps is None:
            iters = 0
            while not self.is_terminal(self.states[-1]):
                self._step_state(function_buffer)
                iters += 1
                ## This is useful for verbose height for each orbit
                # if len(self.states) > 3 and self.states[-1][0] < self.states[-2][0] and self.states[-2][0] > self.states[-3][0]:
                #     print(f"height = {np.linalg.norm(self.states[-1][:self.dim])}")
        else:
            for i in tqdm(range(steps)):
                if self.is_terminal(self.states[-1]):
                    iters = i
                    break
                self._step_state(function_buffer)
            else:
                iters = steps

        print(f"Ran {iters} iterations at time step of {self.time_step} seconds")


class RK4Simulator(Simulator, method_name="RK4"):
    """
    Simulator class implementing the 4th order Runge-Kutta (RK4) integration method.
    """

    def _next_state(self, state, time) -> np.ndarray:
        """
        Calculate the next state using the 4th order Runge-Kutta (RK4) method.

        :param state: The current state vector.
        :type state: np.ndarray
        :param time: The current simulation time.
        :type time: float
        :return: The next state vector.
        :rtype: np.ndarray
        """
        next_state = np.array(state)
        k1 = self._objective_function(state, time)
        k2 = self._objective_function(
            (state + (self.time_step * k1) / 2),
            (time + self.time_step / 2),
        )
        k3 = self._objective_function(
            (state + (self.time_step * k2) / 2),
            (time + self.time_step / 2),
        )
        k4 = self._objective_function(
            (state + self.time_step * k3),
            (time + self.time_step),
        )
        next_state += self.time_step * (1 / 6) * (k1 + 2 * k2 + 2 * k3 + k4)
        return next_state

    def _step_state(self) -> None:
        """
        Step the state of the simulation by one time step using the RK4 method.
        """
        self._step_time()
        self.states.append(self._next_state(self.states[-1], self.times[-1]))

    def _run_method(self, steps: int | None) -> None:
        """
        4th order Runge Kutta Numerical Integration Method

        :param steps: The number of steps to run the simulation for. If None, runs until the satellite impacts the Earth.
        :type steps: int or None
        """
        if len(self.noise_types) == 0:
            print(
                f"Running simulation with RK4 integrator without noise"
            )
        else:
            print(
                f"Running simulation with RK4 integrator with {self.noise_types} noise"
            )
        iters = 0
        # Boilerplate code for stepping the simulation
        if steps is None:
            iters = 0
            while not self.is_terminal(self.states[-1]):
                self._step_state()
                iters += 1
        else:
            for i in tqdm(range(steps)):
                if self.is_terminal(self.states[-1]):
                    iters = i
                    break
                self._step_state()
            else:
                iters = steps

        print(f"Ran {iters} iterations at time step of {self.time_step} seconds")


def raise_for_invalid_sim_method(
        sim_method: str
) -> None:
    """Raises ValueError if the given simulation method name is not defined
    :meta private:
    """
    available_methods = list(get_available_sim_methods().keys())
    if sim_method not in available_methods:
        raise ValueError(
            f"Simulation method {sim_method} is not supported. Supported methods are: {available_methods}"
        )


def raise_for_invalid_noise_type(
    noise_types: dict[str, dict | NoiseKwargs] | None
) -> None:
    """Raises ValueError if any of the given list of noise types is not defined
    :meta private:
    """
    if noise_types is None:
        return
    if isinstance(noise_types, str):
        raise ValueError(
            "Noise types must be provided as a dictionary of {noise_name: noise_kwargs}"
        )
    if not set(noise_types.keys()) <= set(Simulator._available_noise_types):
        raise ValueError(
            f"Noise types {list(set(noise_types.keys()) - set(Simulator._available_noise_types))} "
            "are not supported. Supported methods are: {Simulator._available_noise_types=}"
        )


def get_available_sim_methods() -> dict[str, type[Simulator]]:
    """Python magic to find the names of implemented simulation methods.

    :return: A dictionary of simulation method names and their corresponding classes.
    """
    return Simulator._methods

# def get_available_noise_types() -> list[str, type[Simulator]]:
#     """Python magic to find the names of implemented noise methods.

#     Returns:
#         list[str, subclass(Simulator)]: a list of `{name: noise class}`
#     """
#     return Simulator._available_noise_types



def generate_sim_config(
    sim_method: str,
    atmos_model: str,
    initial_state: np.ndarray,
    initial_time: float = 0.0,
    time_step: float = 0.1,
    noise_types: dict[str, dict | NoiseKwargs] | None = None,
    sim_method_kwargs: dict | type[MethodKwargs] | None = None,
    atmos_kwargs: dict | type[AtmosKwargs] | None = None,
) -> SimConfig:
    """Generates a simulation configuration object from the given parameters.

    :param sim_method: The name of the simulation method to use. One of: "euler", "adams_bashforth", "RK4".
    :param atmos_model: The name of the atmosphere model to use. One of: "coesa_atmos", "coesa_atmos_fast", "zero_atmos", "icao_standard_atmos", "simple_atmos".
    :param initial_state: The initial state vector in the form `(position, velocity)`. The dimension of the simulation is inferred from the length of this vector halved.
    :param initial_time: The initial time. Optional, default `0.0`.
    :param time_step: The time step for the simulation. Optional, default `0.1`.
    :param noise_types: The types of noise to apply to the simulation. Optional.
    :param sim_method_kwargs: The configuration for the simulation method. Optional.
    :param atmos_kwargs: The configuration for the atmosphere model. Optional.
    :return: The configuration object for the simulation.
    """
    assert len(initial_state) % 2 == 0

    if noise_types is None:
        noise_types = {}

    raise_for_invalid_sim_method(sim_method)
    raise_for_invalid_atmos_model(atmos_model)
    raise_for_invalid_noise_type(noise_types)

    dimension: int = int(len(initial_state) / 2)
    method_kwargs_model: type[MethodKwargs] = get_model_for_sim(sim_method)
    atmos_kwargs_model: type[AtmosKwargs] = get_model_for_atmos(atmos_model)

    if sim_method_kwargs is None:
        # Use the defaults set by the data model
        sim_method_kwargs = method_kwargs_model(
            dimension=dimension,
            time_step=time_step,
            noise_types=noise_types,
        )
    elif type(sim_method_kwargs) is dict:
        # If a user supplies time_step in this dictionary, prefer it over the one supplied as an argument
        if "dimension" in sim_method_kwargs:
            dimension = sim_method_kwargs.pop("dimension")
        if "time_step" in sim_method_kwargs:
            time_step = sim_method_kwargs.pop("time_step")
        if "noise_types" in sim_method_kwargs:
            noise_types = sim_method_kwargs.pop("noise_types")
        sim_method_kwargs = method_kwargs_model(
            dimension=dimension,
            time_step=time_step,
            noise_types=noise_types,
            **sim_method_kwargs,
        )
    elif (
        type(sim_method_kwargs) is not method_kwargs_model
        and type(sim_method_kwargs) in get_available_sim_methods().values()
    ):
        raise ValueError(
            f"Mismatched kwargs object provided. Expected kwargs for {sim_method}, got kwargs for {sim_method_kwargs.method_name}"
        )
    else:
        raise ValueError(
            "Simulation method kwargs are invalid. Must either be a dict, a MethodKwargs instance or None"
        )

    if atmos_kwargs is None:
        # Use the defaults set by the data model
        atmos_kwargs = atmos_kwargs_model()
    elif type(atmos_kwargs) is dict:
        atmos_kwargs = atmos_kwargs_model(**atmos_kwargs)
    elif (
        type(atmos_kwargs) is not atmos_kwargs_model
        and type(atmos_kwargs) in get_available_atmos_models().values()
    ):
        raise ValueError(
            f"Mismatched kwargs object provided. Expected kwargs for {atmos_model}, got kwargs for {atmos_kwargs.atmos_name}"
        )
    else:
        raise ValueError(
            "Atmosphere model kwargs are invalid. Must either be a dict, a AtmosKwargs instance or None"
        )

    config = SimConfig(
        initial_state=initial_state,
        initial_time=initial_time,
        simulation_method=sim_method,
        simulation_method_kwargs=sim_method_kwargs,
        atmosphere_model=atmos_model,
        atmosphere_model_kwargs=atmos_kwargs,
    )
    return config


def run_with_config(
    config: SimConfig,
    steps: int | None = None,
) -> Simulator:
    """Runs a simulation with the given configuration.

    :param config: The configuration object for the simulation.
    :param steps: , defaults to None
    :return: Completed :class:'Simulator' instance
    """
    sim = Simulator(config)
    sim.run(steps=steps)
    return sim


def run(
    sim_method: str,
    atmos_model: str,
    initial_state: npt.ArrayLike,
    initial_time: float = 0.0,
    time_step: float = 0.1,
    noise_types: dict[str, dict | NoiseKwargs] | None = None,
    sim_method_kwargs: dict | type[MethodKwargs] | None = None,
    atmos_kwargs: dict | type[AtmosKwargs] | None = None,
    steps: int | None = None,
) -> Simulator:
    """Runs a simulation with the given parameters.

    :param sim_method: The name of the simulation method to use. One of: "euler", "adams_bashforth", "RK4".
    :param atmos_model: The name of the atmosphere model to use. One of: "coesa_atmos", "coesa_atmos_fast", "zero_atmos", "icao_standard_atmos", "simple_atmos".
    :param initial_state: The initial state vector in the form `(position, velocity)`. The dimension of the simulation is inferred from the length of this vector halved.
    :param initial_time: The initial time. Optional, default `0.0`.
    :param time_step: The time step for the simulation. Optional, default `0.1`.
    :param noise_types: The types of noise to apply to the simulation. Optional.
    :param sim_method_kwargs: The configuration for the simulation method. Optional.
    :param atmos_kwargs: The configuration for the atmosphere model. Optional.
    :param steps: The number of steps to run the simulation for. Optional. Default is to run until the satellite impacts the Earth.
    :return: Completed :class:'Simulator' instance.
    """
    config = generate_sim_config(
        sim_method=sim_method,
        atmos_model=atmos_model,
        initial_state=initial_state,
        initial_time=initial_time,
        time_step=time_step,
        noise_types=noise_types,
        sim_method_kwargs=sim_method_kwargs,
        atmos_kwargs=atmos_kwargs,
    )
    sim = run_with_config(config, steps)
    return sim


if __name__ == "__main__":
    # TODO implement CLI
    breakpoint()
    pass
